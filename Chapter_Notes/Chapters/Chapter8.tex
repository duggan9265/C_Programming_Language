\section{Arrays}

\subsection{Overview}

\begin{itemize}
    \item Variables encountered so far have been \textbf{scalar variables}, capable of holding a single value.
    \item C also supports \textbf{aggregate variables}, which store collections of values.
    \item The two aggregate types in C are:
    \begin{itemize}
        \item Arrays
        \item Structures
    \end{itemize}
    \item This chapter covers \textbf{arrays}.
\end{itemize}

\subsection{One-Dimensional Arrays}

\begin{itemize}
    \item An \textbf{array} is a data structure containing multiple values of the same type.
    \item Individual values are called \textbf{elements}.
    \item Elements are accessed using an \textbf{index (subscript)}.
\end{itemize}

\subsubsection{Array Declaration}

To declare an array, specify the element type and number of elements:

\begin{lstlisting}[caption={One-dimensional array declaration}]
int a[10];
\end{lstlisting}

\begin{itemize}
    \item The array contains 10 integers.
    \item Arrays may be of any type.
    \item Elements are indexed starting at 0.
    \item Valid indices for an array of size $n$ are:
    \[
    0 \text{ to } n-1
    \]
\end{itemize}

Example:

\begin{lstlisting}
a[0] = 1;   /* assigns 1 to first element */
\end{lstlisting}

\subsubsection{Common Array Operations}

Clearing an array:

\begin{lstlisting}[caption={Clearing an array}]
for (int i = 0; i < 10; i++)
    a[i] = 0;
\end{lstlisting}

Reading data into an array:

\begin{lstlisting}[caption={Reading data into an array}]
for (int i = 0; i < 10; i++)
    scanf("%d", &a[i]);
\end{lstlisting}

Summing elements:

\begin{lstlisting}[caption={Summing array elements}]
int sum = 0;

for (int i = 0; i < N; i++)
    sum += a[i];
\end{lstlisting}

\subsubsection{Array Bounds}

\begin{itemize}
    \item C does \textbf{not check array bounds}.
    \item Accessing outside the array produces \textbf{undefined behaviour}.
    \item Common mistake:
    \begin{itemize}
        \item Using indices $1$ to $n$ instead of $0$ to $n-1$.
    \end{itemize}
\end{itemize}

\subsubsection{Array Initialization}

Arrays may be initialized when declared:

\begin{lstlisting}[caption={Array initializer}]
int a[10] = {1,2,3,4,5,6,7,8,9,10};
\end{lstlisting}

\begin{itemize}
    \item Initializer values must be constant expressions.
    \item If fewer values are given, the remaining elements become 0.
\end{itemize}

Example:

\begin{lstlisting}
int a[10] = {0};   /* all elements initialized to 0 */
\end{lstlisting}

\subsubsection{Designated Initializers}

Specific elements may be initialized using designators:

\begin{lstlisting}[caption={Designated initializers}]
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
\end{lstlisting}

\begin{itemize}
    \item Values not specified become 0.
    \item Designators must be integer constant expressions.
    \item Valid designators range from $0$ to $n-1$.
\end{itemize}

\begin{itemize}
    \item If the array length is omitted, the compiler determines the size from the largest designator.
\end{itemize}

\subsubsection{The \texttt{sizeof} Operator}

\begin{itemize}
    \item \texttt{sizeof} determines the size of an array in bytes.
\end{itemize}

Example:

\begin{lstlisting}
sizeof(a)
\end{lstlisting}

\begin{itemize}
    \item If \texttt{a} contains 10 integers and each integer is 4 bytes:
\end{itemize}

\[
sizeof(a) = 40
\]

\begin{itemize}
    \item Element size:

\begin{lstlisting}
sizeof(a[0])
\end{lstlisting}

    \item Number of elements:

\begin{lstlisting}
sizeof(a) / sizeof(a[0])
\end{lstlisting}

\end{itemize}

\subsection{Multidimensional Arrays}

\begin{itemize}
    \item C supports multidimensional arrays.
    \item Two-dimensional arrays are often called \textbf{matrices}.
\end{itemize}

Example:

\begin{lstlisting}[caption={Two-dimensional array}]
int a[5][9];
\end{lstlisting}

\begin{itemize}
    \item 5 rows
    \item 9 columns
\end{itemize}

\subsubsection{Storage Order}

\begin{itemize}
    \item Arrays are stored in \textbf{row-major order}.
    \item Row 0 is stored first, then row 1, etc.
\end{itemize}

\subsubsection{Initializing a Matrix}

Example: identity matrix

\begin{lstlisting}[caption={Identity matrix}]
#define N 10

double ident[N][N];

for (int row = 0; row < N; row++)
    for (int col = 0; col < N; col++)
        if (row == col)
            ident[row][col] = 1.0;
        else
            ident[row][col] = 0.0;
\end{lstlisting}

\begin{itemize}
    \item Multidimensional arrays are less common in C than in some languages.
    \item Arrays of pointers often provide more flexibility.
\end{itemize}

\subsubsection{Multidimensional Initializers}

Example:

\begin{lstlisting}[caption={Multidimensional initializer}]
double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
\end{lstlisting}

\subsection{Variable-Length Arrays}

\begin{itemize}
    \item Normally array size must be a constant expression.
    \item In C99, arrays may use a non-constant size.
    \item These are called \textbf{variable-length arrays (VLAs)}.
\end{itemize}

Example:

\begin{lstlisting}[caption={Variable-length array example}]
#include <stdio.h>

int main(void)
{
    int n;

    printf("How many numbers do you want to reverse? ");
    scanf("%d", &n);

    int a[n];   /* size determined at runtime */

    printf("Enter %d numbers: ", n);

    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);

    printf("In reverse order:");

    for (int i = n-1; i >= 0; i--)
        printf(" %d", a[i]);

    printf("\n");

    return 0;
}
\end{lstlisting}

\subsection{Important Rules and Pitfalls}

\begin{itemize}
    \item Array indices start at 0.
    \item C does not perform bounds checking.
    \item Accessing outside an array causes undefined behaviour.
    \item Arrays store elements contiguously in memory.
    \item Use \texttt{sizeof(a)/sizeof(a[0])} to determine array length.
\end{itemize}